// problem 12
// ------------------------------------------------------
/*

The sequence of triangle numbers is generated by adding the natural numbers. 
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?

*/// ------------------------------------------------------

use std::time::Instant;

use std::collections::HashMap;


fn main() {
    let start = Instant::now();

    // -------------------------------

    let mut n = 1;
    let mut x = 0;

    let mut max_divisors = 0;

    let mut primes:Vec<u64> = vec![2];

    loop {

        x += n;

        let mut x_div = x;
        let mut map: HashMap<u64, u64> = HashMap::new();

        primes = get_primes(x, primes);

        for p in &primes {
            loop {
                if x_div % p != 0 {
                    break;
                }
                x_div = x_div / p;
                if !map.contains_key(&p) {
                    map.insert(*p, 0);
                }
                map.insert(*p, &map[&p]+1);
            }
        }

        let mut divisors = 1;
        for count in map.values() {
            divisors = divisors * (count+1);
        }

        if divisors >= max_divisors {
            max_divisors = divisors;
        }

        if divisors >= 500 {
            break;
        }

        n += 1;
        // if n % 100 == 0 {
        //     println!("checked up to: {} numbers | max divisors: {}", n, max_divisors);
        // }
    }

    println!("first triangle number with over 500 divisors: {}", x);

    // -------------------------------

    let duration = start.elapsed();
    println!("Execution time: {:?}", duration);
}


fn get_primes(n:u64, mut primes:Vec<u64>) -> Vec<u64> {
    if n < primes.last().unwrap_or(&2)+1 {
        return primes;
    }
    let start_point = primes.last().unwrap_or(&2) + 1;
    for i in start_point..(n as f64).sqrt() as u64 {
        let mut is_prime = true;
        for p in &primes {
            if ((i as f64).sqrt() as u64) < *p {
                break;
            }
            if (i as u64) % p == 0 {
                is_prime = false;
            }
        }
        if is_prime {
            primes.push(i as u64);
        }
    }
    return primes;
}